//calc.h

#define NUMBER '0'

void push(double);
double pop(void);
int getop(char[]);
int getch(void);
void ungetch(int);

//getch.cpp

#include <stdio.h>
#define BUFSIZE 100 //максимальный размер буфера

char buf[BUFSIZE]; /* буфер для ungetch, массив символов, куда складываем символы, которые нужно вернуть в поток ввода */
int bufp = 0; /* след, свободная позиция в буфере, когда буфер пуст, равна 0 */

int getch(void){ /* взять (возможно возвращенный) символ */
	return (bufp > 0) ? buf[--bufp] : getchar();
	/* если в буфере есть символы (bufp>0), возвращаем символ с позиции bufp и уменьшаем bufp на 1*/
}

void ungetch(int c){ /* вернуть символ на ввод */
	if (bufp >= BUFSIZE) { //если буфер переполнен, выводим сообщение об ошибке.
		printf("ungetch: too many chars\n");
	}
	else {
		buf[bufp++] = c; //есть место, после последнего символа кладем символ c в буфер
	}
}


//stack.cpp

#include <stdio.h>
#include "calc.h"
#define MAXVAL 100 /* максимальная глубина стека */

int sp = 0; /* следующая свободная позиция в стеке */
double val[MAXVAL]; /* стек */

/* push: положить значение f в стек */
void push(double f) {
	if (sp < MAXVAL) {
		val[sp++] = f;
	}
	else {
		printf("ошибка: стек полон, %g не помещается", f);
	}
}

/* pop: взять с вершины стека и выдать в качестве результата */
double pop(void) {
	if (sp > 0)
		return val[--sp];
	else {
		printf("Error: stack is empty");
		return 0.0;
	}
}


//getop.cpp

#include <ctype.h> // для isdigit, isalpha
#include <stdio.h>
#include <string.h>
#include "calc.h"

int getch(void);
void ungetch(int);

int getop(char s[]) {
	int i, c; //i индекс в строке s, c текущий символ
	while (true) {
		c = getch(); //получаем символ
		s[0] = c; //записываем в s[0]
		if (c != ' ' && c != '\t') {  //если не пробел и не таб
			break; //выходим из цикла
		}
	}
	s[1] = '\0'; //завершаем строку

	if (!isdigit(c) && c != '.' && c != '-') {
		i = 0;
		if (isalpha(c)) {
			while (isalpha(s[++i] = c = getch()));
			s[i] = '\0';
			ungetch(c);
			if (strcmp(s, "sin") == 0){
				return 's';
			}
			if (strcmp(s, "e") == 0){
				return 'e';
			}
			if (strcmp(s, "^") == 0){
				return '^';
			} 
			if (strcmp(s, "q") == 0) {
				return 'q';
			} 
		}
		return c; /* не число */
	}
	i = 0;
	if (c == '-') {
		if (isdigit(c = getch()) || c == '.') {
			s[++i] = c;
		}
		else {
			ungetch(c);
			return '-';
		}
	}
	if (isdigit(c)) /* накапливаем целую часть */
		while (isdigit(s[++i] = c = getch()));
	if (c == '.') /* накапливаем дробную часть */
		while (isdigit(s[++i] = c = getch()));
	s[i] = '\0';

	if (c != EOF){
		ungetch(c);
	}
	return NUMBER;
}

//main.cpp

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "calc.h"
#define MAXOP 100

int main() {
    int type;
    double op1, op2;
    char s[MAXOP];

    printf("Calculator (supports +, -, *, /, ^, e, sin)\n");
    printf("Enter the expression in reverse polish notation (type q to exit)\n");

    while ((type = getop(s)) != EOF) {
        switch (type) {
        case NUMBER:
            push(atof(s));
            break;
        case '+':
            push(pop() + pop());
            break;
        case '*':
            push(pop() * pop());
            break;
        case '-':
            op2 = pop();
            push(pop() - op2);
            break;
        case '/':
            op2 = pop();
            if (op2 != 0.0) {
                push(pop() / op2);
            }
            else {
                printf("Error: division by zero\n");
            }
            break;
        case 's':
            push(sin(pop()));
            break;
        case 'e':
            push(exp(pop()));
            break;
        case '^':
            op2 = pop();
            op1 = pop();
            if (op1 == 0.0 && op2 <= 0.0) {
                printf("Error: base 0 when degree <= 0\n");
            }
            else {
                push(pow(op1, op2));
            } 
            break;
        case 'q':
            return 0;
        case '\n':
            printf("%.8g\n", pop());
            break;
        default:
            printf("Error: undefined operation % s\n", s);
            break;
        }
    }
    return 0;
}
