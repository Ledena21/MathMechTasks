function HammingEncode(d) {
    let b = ""; // для результата
    let p = 0; // счетчик битов четности

    while (d.length > 0) { // идем по исходной строке
        if (b.length + 1 === Math.pow(2, p)) { //если следующая позиция - степень 2
            b += "*"; // то на ее место пока звездочку
            p++; // едем дальше
        } else {
            b += d[0]; // кладем в результат следующий символ
            d = d.slice(1); // убираем этот символ из исходной строки
        }
    }

    let m = [];
    let l = b.length.toString(2).length; // столько бит надо для представления длины b в двоичном виде
    // почему столько: мы взяли длину строки, то есть самый большой номер ее позиции, предыдущие позиции очевидно будут меньше
    for (let j = 1; j <= b.length; j++) { // идем в цикле 
        let bin = j.toString(2); // перевели номер позиции в двоичное число
        m.push(bin.padStart(l, '0').split('').map(Number)); // двоичную строку bin дополнили нулями до длины l,
        // разбили ее на массив символов, то есть отдельные 0 и 1, и положили их в массив в виде чисел
    }

    let r = []; // массив с битами четности, их сейчас посчитаем
    for (let j = 0; j < l; j++) { //идем до l, потому что l - кол-во проверочных битов
        let s = 0; // тут считаем единицы
        for (let k = 0; k < b.length; k++) { // идем по битам закодированной строки
            if (m[k][j] === 1 && b[k] === '1') s++; //если бит участвует в проверке и равен '1', то счетчик++
            //m[k][j] это мы смотрим в матрицу под позицию числа b[k], если посмотрите алгоритм на бумажке Хэмминга, то будет понятно, что это
        }
        r.push(s % 2); // у насчитанных единичек остаток от 2 кладем в массив 
    }

    let res = b.split(''); // разбили строку, чтобы можно было менять элементы
    // зачем? потому что =строка неизменяема, а массив можно менять, мы превратим строку в массив, поменяем его и снова из него склеим строку
    for (let j = 0, k = 0; j < res.length; j++) { // идем по строке
        if (res[j] === "*") res[j] = r[k++]; // меняем звездочку на нужный нам бит четности
    }

    return res.join(''); //сделали снова строку из отдельных чиселок
}

function HammingDecode(d) {
    let b = d.split(''); // разбили входящую строку на массив символов, чтобы можно было их менять
    let m = [];
    let l = b.length.toString(2).length; // количество битов четности снова, уже было выше

    //собираем матрицу тоже как уже было
    for (let j = 1; j <= b.length; j++) { // по длине разбитой строки идем
        let bin = j.toString(2); // превратили позицию в двоичное число
        m.push(bin.padStart(l, '0').split('').map(Number)); //дополнили нулями, записали в массив как число
    }

    //здесь ищем ошибки, в e храним что получаем
    let e = [];
    for (let j = l - 1; j >= 0; j--) { //едем от старшего бита к младшему, чтобы потом не переворачивать
        let s = 0; // счетчик 1
        for (let k = 0; k < b.length; k++) { // идем по исходной строке
            s += m[k][j] * parseInt(b[k]); // на эту строку рядами умножаем матрицу
        }
        e.unshift(s % 2); //что насчитали, кладем в e
    }
    let err = parseInt(e.join(''), 2); // склеиваем числа из e в одну строку и переводим в десятичную систему

    if (typeof err === "number" && err > 0) { // если нашли ошибку и она > 0 и число
        b[err - 1] = b[err - 1] === '1' ? '0' : '1'; //тут тернарный оператор, типа если единичка была меняем на нолик, если нолик то на единичку
    }

    let res = ''; // это будет результат
    for (let j = 0, p = 0; j < b.length; j++) {
        if (j + 1 !== Math.pow(2, p)) { // если позиция не степень двойки
            res += b[j]; // переписываем значение позиции в результат
        } else {
            p++; // едем дальше
        }
    }

    return res;
}

let a = process.argv.slice(2);
let s = a[1];

switch (a[0]) {
    case '-e':
        console.log(HammingEncode(s));
        break;
    case '-d':
        console.log(HammingDecode(s));
        break;
}
